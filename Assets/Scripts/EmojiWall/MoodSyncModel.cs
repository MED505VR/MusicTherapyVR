using Normal.Realtime;
using Normal.Realtime.Serialization;
using UnityEngine;

namespace EmojiWall
{
    [RealtimeModel]

    public partial class MoodSyncModel
    {
        [RealtimeProperty(1, true, true)] private bool _play;
        [RealtimeProperty(2, true, true)] private Color _color;
        [RealtimeProperty(3, true, true)] private Color _light;
    }

/* ----- Begin Normal Autogenerated Code ----- */
    public partial class MoodSyncModel : RealtimeModel {
        public bool play {
            get {
                return _playProperty.value;
            }
            set {
                if (_playProperty.value == value) return;
                _playProperty.value = value;
                InvalidateReliableLength();
                FirePlayDidChange(value);
            }
        }
    
        public UnityEngine.Color color {
            get {
                return _colorProperty.value;
            }
            set {
                if (_colorProperty.value == value) return;
                _colorProperty.value = value;
                InvalidateReliableLength();
                FireColorDidChange(value);
            }
        }
    
        public UnityEngine.Color light {
            get {
                return _lightProperty.value;
            }
            set {
                if (_lightProperty.value == value) return;
                _lightProperty.value = value;
                InvalidateReliableLength();
                FireLightDidChange(value);
            }
        }
    
        public delegate void PropertyChangedHandler<in T>(MoodSyncModel model, T value);
        public event PropertyChangedHandler<bool> playDidChange;
        public event PropertyChangedHandler<UnityEngine.Color> colorDidChange;
        public event PropertyChangedHandler<UnityEngine.Color> lightDidChange;
    
        public enum PropertyID : uint {
            Play = 1,
            Color = 2,
            Light = 3,
        }
    
        #region Properties
    
        private ReliableProperty<bool> _playProperty;
    
        private ReliableProperty<UnityEngine.Color> _colorProperty;
    
        private ReliableProperty<UnityEngine.Color> _lightProperty;
    
        #endregion
    
        public MoodSyncModel() : base(null) {
            _playProperty = new ReliableProperty<bool>(1, _play);
            _colorProperty = new ReliableProperty<UnityEngine.Color>(2, _color);
            _lightProperty = new ReliableProperty<UnityEngine.Color>(3, _light);
        }
    
        protected override void OnParentReplaced(RealtimeModel previousParent, RealtimeModel currentParent) {
            _playProperty.UnsubscribeCallback();
            _colorProperty.UnsubscribeCallback();
            _lightProperty.UnsubscribeCallback();
        }
    
        private void FirePlayDidChange(bool value) {
            try {
                playDidChange?.Invoke(this, value);
            } catch (System.Exception exception) {
                UnityEngine.Debug.LogException(exception);
            }
        }
    
        private void FireColorDidChange(UnityEngine.Color value) {
            try {
                colorDidChange?.Invoke(this, value);
            } catch (System.Exception exception) {
                UnityEngine.Debug.LogException(exception);
            }
        }
    
        private void FireLightDidChange(UnityEngine.Color value) {
            try {
                lightDidChange?.Invoke(this, value);
            } catch (System.Exception exception) {
                UnityEngine.Debug.LogException(exception);
            }
        }
    
        protected override int WriteLength(StreamContext context) {
            var length = 0;
            length += _playProperty.WriteLength(context);
            length += _colorProperty.WriteLength(context);
            length += _lightProperty.WriteLength(context);
            return length;
        }
    
        protected override void Write(WriteStream stream, StreamContext context) {
            var writes = false;
            writes |= _playProperty.Write(stream, context);
            writes |= _colorProperty.Write(stream, context);
            writes |= _lightProperty.Write(stream, context);
            if (writes) InvalidateContextLength(context);
        }
    
        protected override void Read(ReadStream stream, StreamContext context) {
            var anyPropertiesChanged = false;
            while (stream.ReadNextPropertyID(out uint propertyID)) {
                var changed = false;
                switch (propertyID) {
                    case (uint) PropertyID.Play: {
                        changed = _playProperty.Read(stream, context);
                        if (changed) FirePlayDidChange(play);
                        break;
                    }
                    case (uint) PropertyID.Color: {
                        changed = _colorProperty.Read(stream, context);
                        if (changed) FireColorDidChange(color);
                        break;
                    }
                    case (uint) PropertyID.Light: {
                        changed = _lightProperty.Read(stream, context);
                        if (changed) FireLightDidChange(light);
                        break;
                    }
                    default: {
                        stream.SkipProperty();
                        break;
                    }
                }
                anyPropertiesChanged |= changed;
            }
            if (anyPropertiesChanged) {
                UpdateBackingFields();
            }
        }
    
        private void UpdateBackingFields() {
            _play = play;
            _color = color;
            _light = light;
        }
    
    }
/* ----- End Normal Autogenerated Code ----- */
}